/**
 * @file firestore.rules
 * @description Security rules for the Vesotel Jornada application.
 *
 * @section Core Philosophy
 * This ruleset enforces a strict user-ownership model. All data that is private to a user
 * (such as their profile, work logs, and settings) is stored in a way that access is granted
 * if and only if the requesting user's authenticated UID matches the user ID in the document path.
 * This approach provides strong security guarantees by default.
 *
 * @section Data Structure
 * Data is organized into two main branches under `/artifacts/{appId}`:
 * 1. `/users/{userId}`: A private tree containing user-specific subcollections like `work_logs` and `settings`. Access to this entire tree is controlled by the `{userId}` wildcard.
 * 2. `/public/data`: A tree for collections that are either publicly readable or have different access patterns. This includes user profiles (`users`), access requests, and the list of allowed users.
 *
 * @section Key Security Decisions
 * - User Enumeration is Disallowed: The top-level `/users` collection cannot be listed, preventing clients from discovering all users of the application.
 * - Strict Ownership: A user can only access (`get`, `list`, `create`, `update`, `delete`) documents that are explicitly under their own user ID path (`/users/{userId}/...`) or their specific user profile document.
 * - Admin-Managed Collections: Collections like `allowed_users` and `access_requests` are client-immutable. They are intended to be managed by a backend process or admin SDK, ensuring the integrity of the access control list.
 * - Self-Creation of Profiles: A newly authenticated user is permitted to create their own user profile document (`/public/data/users/{userId}`) and their own settings document.
 *
 * @section Denormalization for Authorization
 * The security model relies on path-based ownership (`/users/{userId}`). To ensure relational integrity, documents created within this path (e.g., a WorkLog) must contain a `userId` field that matches the `{userId}` from the path. This link is enforced on creation and made immutable on update, creating a secure and performant binding without needing extra `get()` calls.
 *
 * @section Structural Segregation
 * The ruleset separates private user data (`/users/{userId}/...`) from semi-public or admin-managed data (`/public/data/...`). This clean separation allows for simple, path-based rules and prevents accidental data exposure.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ------------------------------------------------------------------------
    // Helper Functions
    // ------------------------------------------------------------------------

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the authenticated user's UID matches the provided userId.
     * This is the primary function for enforcing document ownership.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Verifies that a document exists before an operation.
     * Crucial for secure update and delete operations.
     */
    function isExistingDoc() {
      return resource != null;
    }

    /**
     * Combines ownership check with an existence check.
     * Used for all update and delete operations on user-owned documents.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && isExistingDoc();
    }

    /**
     * Validates that a user is creating their own user profile document and
     * that the internal 'uid' field matches their auth UID for integrity.
     */
    function isCreatingOwnUserDoc(userId) {
      return isOwner(userId) && request.resource.data.uid == userId;
    }

    /**
     * Validates that a user is updating their own profile and ensures the
     * 'uid' field, which links to their auth identity, cannot be changed.
     */
    function isUpdatingOwnUserDoc(userId) {
      return isExistingOwner(userId) && request.resource.data.uid == resource.data.uid;
    }
    
    /**
     * Validates that a user is creating a document in their own subcollection
     * and that the internal 'userId' field matches their auth UID for integrity.
     */
    function isCreatingOwnSubDoc(userId) {
      return isOwner(userId) && request.resource.data.userId == userId;
    }

    /**
     * Validates that a user is updating a document in their own subcollection
     * and ensures the 'userId' field cannot be changed, preventing re-assignment.
     */
    function isUpdatingOwnSubDoc(userId) {
      return isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
    }

    // ------------------------------------------------------------------------
    // Rule Definitions
    // ------------------------------------------------------------------------
    
    match /artifacts/{appId} {

      /**
       * @description Defines rules for the shared data space, including user profiles,
       * access requests, and the list of allowed users.
       * @path /artifacts/{appId}/public/data
       */
      match /public/data {

        /**
         * @description Secures user profile documents. Users can create, read, and update their own
         * profile, but cannot see or list profiles of other users.
         * @path /artifacts/{appId}/public/data/users/{userId}
         * @allow (create) An authenticated user with UID 'user123' creating their own profile at `/users/user123`.
         * @deny (list) Any user trying to list all documents in the `/users` collection.
         * @deny (get) User 'user123' trying to read the profile at `/users/user456`.
         * @principle Restricts access to a user's own data tree and prevents user enumeration.
         */
        match /users/{userId} {
          allow get: if isOwner(userId);
          allow list: if false;
          allow create: if isCreatingOwnUserDoc(userId);
          allow update: if isUpdatingOwnUserDoc(userId);
          allow delete: if isExistingOwner(userId);
        }

        /**
         * @description Manages requests for application access. Anyone can submit a request,
         * but these requests cannot be read, modified, or deleted from the client-side.
         * Management must be handled by a trusted backend service or admin.
         * @path /artifacts/{appId}/public/data/access_requests/{accessRequestId}
         * @allow (create) An unauthenticated visitor creating a new access request.
         * @deny (get, list, update, delete) Any user trying to read or modify existing requests.
         * @principle Enforces a "write-once" pattern for public submissions, securing all subsequent operations for admin-only access.
         */
        match /access_requests/{accessRequestId} {
          allow get: if false; // TODO: Implement admin-only access rule
          allow list: if false; // TODO: Implement admin-only access rule
          allow create: if true;
          allow update: if false; // TODO: Implement admin-only access rule
          allow delete: if false; // TODO: Implement admin-only access rule
        }

        /**
         * @description A read-only list of users who are permitted to use the application.
         * This collection is managed by a backend process. Authenticated clients can read it
         * to verify access, but cannot modify it.
         * @path /artifacts/{appId}/public/data/allowed_users/{allowedUserId}
         * @allow (get, list) Any authenticated user reading the collection.
         * @deny (create, update, delete) Any user attempting to modify the allow-list.
         * @principle Protects critical application configuration by making it read-only for clients.
         */
        match /allowed_users/{allowedUserId} {
          allow get: if isSignedIn();
          allow list: if isSignedIn();
          allow create: if false;
          allow update: if false;
          allow delete: if false;
        }
      }

      /**
       * @description This is the root path for a user's private data. Direct writes to this
       * path are disallowed to enforce that all data must live within a designated subcollection
       * like `work_logs` or `settings`.
       * @path /artifacts/{appId}/users/{userId}
       * @deny (create) Any user trying to create a document directly at `/users/{userId}`.
       * @principle Enforces a structured data hierarchy by treating this path as a container only.
       */
      match /users/{userId} {
        allow read: if false;
        allow write: if false;

        /**
         * @description Secures user-specific work log entries. A user has full control over their own logs
         * but has no access to anyone else's.
         * @path /artifacts/{appId}/users/{userId}/work_logs/{workLogId}
         * @allow (create, list) User 'user123' creating or listing work logs under `/users/user123/work_logs`.
         * @deny (get) User 'user456' trying to read a work log under `/users/user123/work_logs`.
         * @principle Enforces document ownership for all operations within a user-specific subcollection.
         */
        match /work_logs/{workLogId} {
          allow get: if isOwner(userId);
          allow list: if isOwner(userId);
          allow create: if isCreatingOwnSubDoc(userId);
          allow update: if isUpdatingOwnSubDoc(userId);
          allow delete: if isExistingOwner(userId);
        }

        /**
         * @description Secures the user's single configuration document. A user can read and modify
         * their own settings.
         * @path /artifacts/{appId}/users/{userId}/settings/config
         * @allow (get, update) User 'user123' reading or updating their config doc at `/users/user123/settings/config`.
         * @deny (get) User 'user456' attempting to read the config doc for 'user123'.
         * @principle Enforces document ownership for a singleton document within a user's private data tree.
         */
        match /settings/config {
          allow get: if isOwner(userId);
          allow list: if isOwner(userId); // list is allowed but applies to a single document path
          allow create: if isCreatingOwnSubDoc(userId);
          allow update: if isUpdatingOwnSubDoc(userId);
          allow delete: if isExistingOwner(userId);
        }
      }
    }
  }
}