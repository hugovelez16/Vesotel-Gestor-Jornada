
/**
 * @file firestore.rules
 * @description Security rules for the Vesotel Jornada application.
 *
 * @section Core Philosophy
 * This ruleset enforces a strict user-ownership model. All data that is private to a user
 * (such as their profile, work logs, and settings) is stored in a way that access is granted
 * if and only if the requesting user's authenticated UID matches the user ID in the document path.
 * This approach provides strong security guarantees by default.
 *
 * @section Data Structure
 * Data is organized into two main branches under `/artifacts/{appId}`:
 * 1. `/users/{userId}`: A private tree containing user-specific subcollections like `work_logs` and `settings`. Access to this entire tree is controlled by the `{userId}` wildcard.
 * 2. `/public/data`: A tree for collections that are either publicly readable or have different access patterns. This includes user profiles (`users`), access requests, and the list of allowed users.
 *
 * @section Key Security Decisions
 * - User Enumeration is Disallowed: The top-level `/users` collection cannot be listed by regular users, preventing clients from discovering all users of the application. Admins, however, can list users.
 * - Strict Ownership: A user can only access (`get`, `list`, `create`, `update`, `delete`) documents that are explicitly under their own user ID path (`/users/{userId}/...`) or their specific user profile document.
 * - Admin-Managed Collections: Collections like `allowed_users` and `access_requests` are client-immutable. They are intended to be managed by a backend process or admin SDK, ensuring the integrity of the access control list.
 * - Self-Creation of Profiles: A newly authenticated user is permitted to create their own user profile document (`/public/data/users/{userId}`) and their own settings document.
 *
 * @section Denormalization for Authorization
 * The security model relies on path-based ownership (`/users/{userId}`). To ensure relational integrity, documents created within this path (e.g., a WorkLog) must contain a `userId` field that matches the `{userId}` from the path. This link is enforced on creation and made immutable on update, creating a secure and performant binding without needing extra `get()` calls.
 *
 * @section Structural Segregation
 * The ruleset separates private user data (`/users/{userId}/...`) from semi-public or admin-managed data (`/public/data/...`). This clean separation allows for simple, path-based rules and prevents accidental data exposure.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ------------------------------------------------------------------------
    function isExistingDoc() {
      return resource != null;
    }

    /**
     * Combines ownership check with an existence check.
     * Used for all update and delete operations on user-owned documents.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && isExistingDoc();
    }

    /**
     * Validates that a user is creating their own user profile document and
     * that the internal 'uid' field matches their auth UID for integrity.
     */
    function isCreatingOwnUserDoc(userId) {
      return isOwner(userId) && request.resource.data.uid == userId;
    }

    /**
     * Validates that a user is updating their own profile and ensures the
     * 'uid' field, which links to their auth identity, cannot be changed.
     */
    function isUpdatingOwnUserDoc(userId) {
      return isExistingOwner(userId) && request.resource.data.uid == resource.data.uid;
    }
    
    /**
     * Validates that a user is creating a document in their own subcollection
     * and that the internal 'userId' field matches their auth UID for integrity.
     */
    function isCreatingOwnSubDoc(userId) {
      return isOwner(userId) && request.resource.data.userId == userId;
    }

    /**
     * Validates that a user is updating a document in their own subcollection
     * and ensures the 'userId' field cannot be changed, preventing re-assignment.
     */
    function isUpdatingOwnSubDoc(userId) {
      return isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
    }

    // ------------------------------------------------------------------------
    // Rule Definitions
    // ------------------------------------------------------------------------
    
    match /artifacts/{appId} {

      /**
       * @description This is a special rule to allow admins to perform a collection group query
       * across all `work_logs` collections. This is necessary for admin views like the timeline.
       * @path /users/{userId}/work_logs/{workLogId} -> captured by this recursive wildcard match
       * @allow (list) Admin can list any work log via a collection group query.
       * @principle Provides a specific, narrow permission for a powerful query type needed by a specific feature.
       */
      match /{path=**}/work_logs/{workLogId} {
        allow list: if isAdmin();
      }
      
      /**
       * @description Defines rules for the shared data space, including user profiles,
       * access requests, and the list of allowed users.
       * @path /artifacts/{appId}/public/data
       */
      match /public/data {

        /**
         * @description Secures user profile documents. Users can create, read, and update their own
         * profile, but cannot see or list profiles of other users. Admins can read all profiles.
         * @path /artifacts/{appId}/public/data/users/{userId}
         * @allow (get, list) Admin can read any user profile.
         * @allow (create) An authenticated user with UID 'user123' creating their own profile at `/users/user123`.
         * @deny (list) A non-admin user trying to list all documents in the `/users` collection.
         * @deny (get) User 'user123' trying to read the profile at `/users/user456`.
         * @principle Restricts access to a user's own data tree and prevents user enumeration, except for admins.
         */
        match /users/{userId} {
          allow get: if isOwner(userId) || isAdmin();
          allow list: if isAdmin();
          allow create: if isCreatingOwnUserDoc(userId);
          allow update: if isUpdatingOwnUserDoc(userId);
          allow delete: if isExistingOwner(userId) || isAdmin();
        }

        /**
         * @description Manages requests for application access. Anyone can submit a request,
         * but these requests can only be managed by an admin.
         * @path /artifacts/{appId}/public/data/access_requests/{accessRequestId}
         * @allow (create) An unauthenticated visitor creating a new access request.
         * @allow (read, list, update) Admin can manage all access requests.
         * @deny (get, list, update, delete) Any non-admin user trying to read or modify existing requests.
         * @principle Enforces a "write-once" pattern for public submissions, securing all subsequent operations for admin-only access.
         */
        match /access_requests/{accessRequestId} {
          allow get: if isAdmin();
          allow list: if isAdmin();
          allow create: if true;
          allow update: if isAdmin();
          allow delete: if isAdmin();
        }

        /**
         * @description A list of users who are permitted to use the application.
         * This collection is readable by authenticated users but can only be written to by admins.
         * @path /artifacts/{appId}/public/data/allowed_users/{allowedUserId}
         * @allow (read, list) Any authenticated user can check the list.
         * @allow (write) Only an admin can add or remove users.
         * @deny (create, update, delete) Any non-admin user attempting to modify the allow-list.
         * @principle Protects critical application configuration by making it read-only for regular clients.
         */
        match /allowed_users/{allowedUserId} {
          allow get: if isSignedIn();
          allow list: if isSignedIn();
          allow create: if isAdmin();
          allow update: if isAdmin();
          allow delete: if isAdmin();
        }
      }

      /**
       * @description This is the root path for a user's private data. Direct writes to this
       * path are disallowed to enforce that all data must live within a designated subcollection
       * like `work_logs` or `settings`.
       * @path /artifacts/{appId}/users/{userId}
       * @deny (create) Any user trying to create a document directly at `/users/{userId}`.
       * @principle Enforces a structured data hierarchy by treating this path as a container only.
       */
      match /users/{userId} {
        allow read: if false;
        allow write: if false;
        
        /**
         * @description Secures the user's work log documents. A user can fully manage their own
         * work logs, and an admin can read them.
         * @path /artifacts/{appId}/users/{userId}/work_logs/{workLogId}
         * @allow (get) User 'user123' reading their own work log.
         * @allow (get) Admin can read any work log.
         * @allow (create) User 'user123' creating a new work log in their own space.
         * @deny (list) Regular users cannot list work logs from here; must use a secure query.
         * @principle Enforces document ownership for CRUD operations with an admin read-only override.
         */
        match /work_logs/{workLogId} {
          allow get: if isOwner(userId) || isAdmin();
          allow list: if isOwner(userId) || isAdmin();
          allow create: if isCreatingOwnSubDoc(userId);
          allow update: if isUpdatingOwnSubDoc(userId);
          allow delete: if isExistingOwner(userId);
        }

        /**
         * @description Secures the user's single configuration document. A user can manage
         * their own settings. An admin can read them.
         * @path /artifacts/{appId}/users/{userId}/settings/config
         * @allow (get, update) User 'user123' reading or updating their config doc.
         * @allow (get) Admin user can read any user's config.
         * @deny (get) User 'user456' attempting to read the config doc for 'user123'.
         * @principle Enforces document ownership for a singleton document, with read-only exception for admins.
         */
        match /settings/config {
          allow get: if isOwner(userId) || isAdmin();
          allow list: if isOwner(userId) || isAdmin();
          allow create: if isCreatingOwnSubDoc(userId);
          allow update: if isUpdatingOwnSubDoc(userId);
          allow delete: if isExistingOwner(userId) || isAdmin();
        }
      }
    }
  }
}

    